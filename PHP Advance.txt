                             PHP Advance 
							 
(1)Define Object-Oriented Programming (OOP) and its four main principles: 
   Encapsulation, Inheritance, Polymorphism, and Abstraction.
   
 Ans.Object-Oriented Programming (OOP):
A programming paradigm based on the concept of objects, which contain data (attributes) and behavior (methods). It helps in organizing code into reusable, modular, and maintainable structures.

Encapsulation: The process of bundling data and methods together within a class, while restricting direct access to some of the object’s components to protect data integrity.

Inheritance: The mechanism that allows a class to acquire properties and methods of another class, enabling code reuse and establishing hierarchical relationships.

Polymorphism: The ability of different classes to provide different implementations of methods with the same name, allowing one interface to be used for multiple forms.

Abstraction: The concept of hiding implementation details and exposing only the essential features, usually achieved through abstract classes or interfaces.  


(2) Explain the structure of a class in PHP, including properties and methods

In PHP, a class is a template or blueprint that defines how objects are created and how they behave. A class is made up of two main components:

Properties

Properties are variables that belong to a class.

They represent the attributes or characteristics of the object.

For example, a “Student” class may have properties like name, email, and age.

Properties can have visibility defined as public, private, or protected to control access.

Methods

Methods are functions that belong to a class.

They define the behavior or actions that an object can perform.

For example, a “Student” class might have methods like enroll(), getDetails(), or updateProfile().

Like properties, methods can also have visibility (public, private, protected).


(3) What is an object in OOP? Discuss how objects are instantiated from classes in PHP

What is an Object in OOP?

An object is an instance of a class.

A class is just a blueprint or template, and the object is the actual usable entity created from it.

Objects represent real-world entities with their own properties (data/attributes) and methods (behaviors/actions).

Each object created from the same class can hold different values for its properties but share the same structure and behavior.



Think of a class as a "Car design".

An object is an actual "Car" made from that design (e.g., Car A, Car B). Each car may have different colors, models, or speeds, but they all follow the same blueprint.

How are Objects Instantiated from Classes in PHP?

In PHP, you create an object using the new keyword followed by the class name.

This process is called instantiation.

When an object is created, its constructor (if defined) is automatically called to initialize properties.



Define a class with properties and methods.

Use the new keyword to create an object from that class.

The object can now access the class’s properties and methods using the -> operator.


(4)Explain the concept of inheritance in OOP and how it is implemented in PHP.

Concept of Inheritance in OOP

Inheritance is one of the main principles of Object-Oriented Programming (OOP).

It allows a class (called the child class or subclass) to acquire properties and methods from another class (called the parent class or base class).

This promotes reusability of code, since common functionality can be defined once in the parent class and then reused or extended by child classes.

The child class can also override methods of the parent class to provide its own specific behavior.

Inheritance creates a natural hierarchy between classes, forming an "is-a" relationship.


Consider a class Vehicle (with properties like color, speed and methods like start(), stop()).

A Car class or Bike class can inherit from Vehicle and get all these properties and methods automatically, while adding their own specific features (like openTrunk() for a Car).

How Inheritance is Implemented in PHP

In PHP, inheritance is achieved using the extends keyword.

A class can inherit only from one parent class (PHP supports single inheritance).

The child class gets access to all public and protected properties and methods of the parent class.

The child can also override parent methods to change behavior.


(5) Discuss method overloading and how it is implemented in PHP


What is Method Overloading?

Method overloading is an OOP concept where multiple methods can have the same name but differ in the number or type of parameters.

It helps achieve polymorphism, meaning the same method name can perform different tasks depending on the input.

In many languages like Java or C++, true method overloading is supported (multiple methods with the same name but different signatures).

Method Overloading in PHP

PHP does not support traditional method overloading like Java or C++.

Instead, PHP provides magic methods (__call() and __callStatic()) to achieve a similar effect.

__call($method, $arguments) → triggered when calling inaccessible or non-existent methods on an object.

__callStatic($method, $arguments) → triggered for inaccessible or non-existent static methods.

Using these magic methods, you can handle different method calls dynamically and simulate overloading behavior.

Key Points in PHP Method Overloading

Only one method with a given name actually exists.

Overloading is achieved by intercepting calls to undefined methods.

The arguments passed are handled dynamically inside __call() or __callStatic().


(6) Explain the concept of abstraction and the use of interfaces in PHP.


oncept of Abstraction in OOP

Abstraction is one of the core principles of Object-Oriented Programming (OOP).

It means hiding the internal implementation details of a system and exposing only the essential features to the user.

The focus is on what an object does, not on how it does it.

Abstraction allows developers to design systems at a high level without worrying about the complexity underneath.



When you drive a car, you just use the steering wheel, accelerator, and brakes.

You don’t need to know the complex internal working of the engine.

This is abstraction—you interact with only the essential features.


(7) What is a constructor in PHP? Discuss its purpose and how it is used.

What is a Constructor in PHP?

A constructor is a special method in a class that is automatically executed whenever an object of that class is created.

In PHP, the constructor method is defined using the __construct() function.

It does not return anything and is mainly used for initializing object properties at the time of object creation.

Purpose of a Constructor

Initialization of Properties – Assign default or dynamic values to class properties when an object is created.

Dependency Injection – Pass necessary objects or resources directly when instantiating a class.

Code Reusability – Avoid writing separate initialization code each time an object is created.

Automation – Reduce manual setup, since constructors run automatically.

How a Constructor is Used in PHP

A constructor is defined using public function __construct(...) { ... } inside the class.

When you use the new keyword to create an object, PHP automatically calls this constructor.

Parameters can also be passed to the constructor, making it possible to initialize objects with custom values.


(8) Explain the role of a destructor in PHP and when it is called.

What is a Destructor in PHP?

A destructor is a special method in a class, just like a constructor, but it is executed when an object is destroyed or no longer needed.

In PHP, it is defined using the __destruct() method.

Unlike a constructor, a destructor does not take parameters.

Role of a Destructor

The main purpose of a destructor is to free up resources or perform cleanup tasks before an object is completely removed from memory.

Typical uses include:

Closing database connections.

Releasing file handles or network connections.

Saving final logs or data before termination.

Cleaning temporary data or cache used by the object.

When is a Destructor Called?

A destructor is automatically called in these situations:

When a script ends and objects go out of scope.

When you unset() an object explicitly.

When there are no more references to an object.

(9) Define magic methods in PHP. Discuss commonly used magic methods like __get(), __set(), and __construct().

What are Magic Methods in PHP?

Magic methods in PHP are special methods that start with double underscores (__).

They are built-in methods automatically triggered by PHP when certain events occur (like creating an object, setting inaccessible properties, or converting an object to a string).

These methods provide flexibility and allow developers to customize object behavior.

Commonly Used Magic Methods
1. __construct()

The constructor method.

It is called automatically when an object is created.

Main purpose: Initialize properties or set up resources for the object.

2. __get($property)

Triggered when trying to access an inaccessible or non-existing property of an object.

Useful when you want to control how property values are retrieved dynamically.

3. __set($property, $value)

Triggered when trying to set a value to an inaccessible or non-existing property.

Commonly used for encapsulation or when working with private/protected properties.

(10) Explain the scope resolution operator (::) and its use in PHP.

  Scope Resolution Operator (::) in PHP

The scope resolution operator (::) is a special operator in PHP that allows access to static properties, static methods, and constants of a class without creating an object.

It is also known as the Paamayim Nekudotayim operator (a Hebrew phrase meaning “double colon”).

Uses of :: in PHP

Accessing Static Properties and Methods

Since static members belong to the class (not objects), they are accessed using ClassName::property or ClassName::method().

Accessing Class Constants

Constants defined with const inside a class can be accessed using ClassName::CONSTANT_NAME.

Accessing Parent Class Members

It is used with the keyword parent:: to call parent class methods or constructors in inheritance.

Accessing the Current Class

It can be used with self:: to refer to the current class’s static properties or methods.


(11) Define traits in PHP and their purpose in code reuse.

Traits in PHP

A Trait in PHP is a mechanism for code reuse in single inheritance languages like PHP.

PHP does not support multiple inheritance (a class can only extend one parent class).

Traits solve this limitation by allowing developers to reuse methods across multiple classes without duplication.

Purpose of Traits

Code Reuse

Instead of rewriting the same methods in different classes, traits let you write the method once and use it in multiple classes.

Avoiding Multiple Inheritance Issues

Since PHP does not allow a class to inherit from more than one class, traits provide a way to share behavior without inheritance.

Better Organization

Traits help keep code modular and organized by grouping related methods together.

Conflict Resolution

If two traits have methods with the same name, PHP allows conflict resolution using insteadof and as operators.



(12) Discuss the visibility of properties and methods in PHP (public, private, protected).

Visibility of Properties and Methods in PHP

In PHP (and OOP in general), visibility controls how properties and methods of a class can be accessed from inside or outside the class. PHP provides three levels of visibility:

1. Public

Accessible everywhere: inside the class, by child classes, and from outside the class.

It is the default visibility if no modifier is specified.

Used when you want methods or properties to be available for general use.

2. Private

Accessible only inside the class where it is declared.

Not accessible from child classes or outside code.

Used to hide implementation details and enforce encapsulation.

3. Protected

Accessible inside the class itself and its child (subclass).

Not accessible directly from outside the class.

Useful when you want child classes to inherit and use properties/methods but not expose them publicly.


(13) Explain type hinting in PHP and its benefits.

 Type hinting in PHP is the practice of specifying the expected data type for function parameters, return values, and class properties.
It tells PHP (and developers) what type of value a function or method should accept or return.

Since PHP 7 and later, type hinting became stricter and more powerful, supporting scalar types (like int, string, bool) as well as class names, arrays, and objects.

Benefits of Type Hinting

Improves Code Reliability

Prevents invalid data types from being passed into functions.

Reduces runtime errors caused by unexpected inputs.

Enhances Readability

Makes the code self-explanatory by clearly defining what kind of data is expected.

Encourages Better Code Design

Forces developers to think about data types and function responsibilities.

Easier Debugging

PHP throws errors when incorrect types are passed, making it easier to identify issues early.

Supports IDEs and Autocompletion

Modern IDEs can provide better suggestions and detect errors before running the code.

(14) Discuss the purpose of the final keyword in PHP and how it affects classes and methods

The final Keyword in PHP

The final keyword in PHP is used to restrict inheritance and method overriding in Object-Oriented Programming (OOP). It can be applied to classes and methods.

1. Final Class

When a class is declared as final, it cannot be inherited by any other class.

This is useful when you want to prevent extension of a class to maintain strict behavior.

Example use case: Utility or security-related classes where modification could break functionality.

2. Final Method

When a method is declared as final, it cannot be overridden by child classes.

The method can still be inherited, but the child class must use it as-is.

This ensures that the core behavior of a method remains unchanged.


(15) Explain the importance of email security and common practices to ensure secure email
transmission.

Importance of Email Security

Email is one of the most widely used communication tools, both personally and professionally. However, it is also a major target for cyberattacks such as phishing, spam, malware distribution, and data theft. Ensuring secure email transmission is critical because:

Confidentiality – Emails may contain sensitive personal or business information that must be protected from unauthorized access.

Integrity – Ensures that the message is not altered or tampered with during transmission.

Authentication – Helps verify that the sender is genuine and not an impersonator.

Availability – Protects against email system disruptions caused by spamming or denial-of-service attacks.

Legal and Compliance – Many industries must comply with regulations (e.g., GDPR, HIPAA) that require secure handling of communications.


(16) Discuss file handling in PHP, including opening, reading, writing, and closing files.

File handling in PHP allows developers to create, open, read, write, and close files on the server. It is an important feature for working with data storage, log files, configuration files, and generating reports.

Modes:

"r" → Read only, starts at the beginning.

"w" → Write only, erases existing content.

"a" → Write only, appends data.

"x" → Creates a new file, returns error if file exists.

"r+" → Read/Write, starts at the beginning.

"w+" → Read/Write, truncates file.

"a+" → Read/Write, appends content.


(17) Explain how to send emails in PHP using the mail() function and the importance of
validating email addresses.

PHP provides the built-in mail() function to send emails directly from a script. It is commonly used for contact forms, notifications, and account verification.

1. Syntax of mail()
mail(to, subject, message, headers, parameters);


to → Recipient email address

subject → Subject of the email

message → Body of the email

headers → Additional information (From, CC, BCC, Reply-To, Content-Type, etc.)

parameters → Optional settings for mail configuration


(18) Discuss the Model-View-Controller (MVC) architecture and its advantages in web
development.

MVC is a design pattern widely used in web development to organize code in a structured and maintainable way. It separates an application into three interconnected components:

1. Model

Represents the data and business logic of the application.

Interacts with the database (fetch, insert, update, delete records).

Contains rules, calculations, and data processing logic.

Example: A User model that handles user-related data.

2. View

Handles the presentation layer (UI).

Displays data from the model to the user.

Contains HTML, CSS, JavaScript, and sometimes templating engines.

Example: A profile.blade.php file in Laravel that shows user info.

3. Controller

Acts as a mediator between Model and View.

Receives requests from users, processes them using Models, and returns the appropriate View.

Example: A UserController that fetches data from the User model and passes it to a profile view

(19) Explain how to connect PHP to a MySQL database using mysqli or PDO.

Connecting PHP to MySQL Database

In PHP, you can connect to a MySQL database using two common extensions:

MySQLi (MySQL Improved)

PDO (PHP Data Objects)

Both allow you to interact with the database (insert, update, delete, fetch data).

1. Using MySQLi

MySQLi supports procedural and object-oriented styles.

Example (Procedural Style):
<?php
$servername = "localhost";
$username   = "root";
$password   = "";
$database   = "testdb";

// Create connection
$conn = mysqli_connect($servername, $username, $password, $database);

// Check connection
if (!$conn) {
    die("Connection failed: " . mysqli_connect_error());
}
echo "Connected successfully";
?>


(20) Define SQL injection and its implications on security.

SQL Injection is a web security vulnerability that occurs when an attacker is able to insert or manipulate malicious SQL queries in the input fields of a web application, which are then executed by the database.

It happens when user inputs are not properly validated or sanitized, and they are directly used in SQL queries.


(21) Explain the differences between sessions and cookies in PHP.

1. Sessions in PHP

Definition: A session is a way to store user information (variables) to be used across multiple pages.

Storage: Data is stored on the server (only the session ID is stored in the browser cookie).

Lifetime: Active until the user closes the browser or the session times out.

Security: More secure because data is not stored on the client-side.

Use case: Login systems, shopping carts, storing temporary user preferences.


(22) Discuss file upload functionality in PHP and its security implications. 


File Upload Functionality in PHP

File upload allows users to upload files (images, documents, etc.) from their local machine to the server. PHP provides the $_FILES superglobal to handle uploaded files.

Steps in File Upload

HTML Form with enctype="multipart/form-data"

<form action="upload.php" method="POST" enctype="multipart/form-data">
    <input type="file" name="fileToUpload">
    <input type="submit" value="Upload">
</form>


PHP Script to Handle Upload

<?php
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
    $targetDir = "uploads/";
    $targetFile = $targetDir . basename($_FILES["fileToUpload"]["name"]);

    if (move_uploaded_file($_FILES["fileToUpload"]["tmp_name"], $targetFile)) {
        echo "File uploaded successfully!";
    } else {
        echo "Error uploading file.";
    }
}
?>

(23) Implement a CRUD application (Create, Read, Update, Delete) using the MVC architecturetomanage user data.

Database Table
CREATE DATABASE crud_mvc;
USE crud_mvc;

CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

3. config.php (Database Connection)
<?php
$host = "localhost";
$user = "root";
$pass = "";
$db   = "crud_mvc";

$conn = new mysqli($host, $user, $pass, $db);

if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
}
?>

4. Model → models/User.php
<?php
class User {
    private $conn;
    private $table = "users";

    public function __construct($db) {
        $this->conn = $db;
    }

    // Create User
    public function create($name, $email) {
        $stmt = $this->conn->prepare("INSERT INTO $this->table (name, email) VALUES (?, ?)");
        $stmt->bind_param("ss", $name, $email);
        return $stmt->execute();
    }

    // Read All Users
    public function getAll() {
        $result = $this->conn->query("SELECT * FROM $this->table");
        return $result->fetch_all(MYSQLI_ASSOC);
    }

    // Get User by ID
    public function getById($id) {
        $stmt = $this->conn->prepare("SELECT * FROM $this->table WHERE id=?");
        $stmt->bind_param("i", $id);
        $stmt->execute();
        return $stmt->get_result()->fetch_assoc();
    }

    // Update User
    public function update($id, $name, $email) {
        $stmt = $this->conn->prepare("UPDATE $this->table SET name=?, email=? WHERE id=?");
        $stmt->bind_param("ssi", $name, $email, $id);
        return $stmt->execute();
    }

    // Delete User
    public function delete($id) {
        $stmt = $this->conn->prepare("DELETE FROM $this->table WHERE id=?");
        $stmt->bind_param("i", $id);
        return $stmt->execute();
    }
}
?>

5. Controller → controllers/UserController.php
<?php
require_once "models/User.php";

class UserController {
    private $userModel;

    public function __construct($db) {
        $this->userModel = new User($db);
    }

    // List Users
    public function index() {
        $users = $this->userModel->getAll();
        include "views/users/index.php";
    }

    // Show Create Form
    public function createForm() {
        include "views/users/create.php";
    }

    // Store New User
    public function store($name, $email) {
        $this->userModel->create($name, $email);
        header("Location: index.php?action=index");
    }

    // Show Edit Form
    public function editForm($id) {
        $user = $this->userModel->getById($id);
        include "views/users/edit.php";
    }

    // Update User
    public function update($id, $name, $email) {
        $this->userModel->update($id, $name, $email);
        header("Location: index.php?action=index");
    }

    // Delete User
    public function delete($id) {
        $this->userModel->delete($id);
        header("Location: index.php?action=index");
    }
}
?>

6. Front Controller → index.php
<?php
require_once "config.php";
require_once "controllers/UserController.php";

$controller = new UserController($conn);

// Routing
$action = $_GET['action'] ?? 'index';

switch ($action) {
    case 'index':
        $controller->index();
        break;
    case 'create':
        $controller->createForm();
        break;
    case 'store':
        $controller->store($_POST['name'], $_POST['email']);
        break;
    case 'edit':
        $controller->editForm($_GET['id']);
        break;
    case 'update':
        $controller->update($_POST['id'], $_POST['name'], $_POST['email']);
        break;
    case 'delete':
        $controller->delete($_GET['id']);
        break;
    default:
        echo "Page not found!";
}
?>

7. Views
views/users/index.php
<!DOCTYPE html>
<html>
<head>
    <title>User List</title>
</head>
<body>
    <h2>All Users</h2>
    <a href="index.php?action=create">Add User</a>
    <table border="1" cellpadding="5">
        <tr><th>ID</th><th>Name</th><th>Email</th><th>Actions</th></tr>
        <?php foreach ($users as $user): ?>
        <tr>
            <td><?= $user['id'] ?></td>
            <td><?= $user['name'] ?></td>
            <td><?= $user['email'] ?></td>
            <td>
                <a href="index.php?action=edit&id=<?= $user['id'] ?>">Edit</a>
                <a href="index.php?action=delete&id=<?= $user['id'] ?>" onclick="return confirm('Delete this user?')">Delete</a>
            </td>
        </tr>
        <?php endforeach; ?>
    </table>
</body>
</html>

views/users/create.php
<h2>Add New User</h2>
<form action="index.php?action=store" method="POST">
    Name: <input type="text" name="name"><br><br>
    Email: <input type="email" name="email"><br><br>
    <button type="submit">Save</button>
</form>

views/users/edit.php
<h2>Edit User</h2>
<form action="index.php?action=update" method="POST">
    <input type="hidden" name="id" value="<?= $user['id'] ?>">
    Name: <input type="text" name="name" value="<?= $user['name'] ?>"><br><br>
    Email: <input type="email" name="email" value="<?= $user['email'] ?>"><br><br>
    <button type="submit">Update</button>
</form>